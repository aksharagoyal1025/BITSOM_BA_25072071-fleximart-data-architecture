## Section A: Limitations of RDBMS
Relational databases work well when the structure of data is fixed and similar for all rows. However, they become difficult to manage when products have very different attributes. For example, a laptop may have RAM, processor, and storage, while a shoe has size, color, and material. In a relational table, this either leads to many nullable columns or many extra tables, which makes the design harder to understand and maintain. Frequent schema changes are also a problem. Every time a new product type is added with new attributes, the table definition must be altered, which can be slow and risky in production systems. Storing customer reviews as nested data, with multiple comments per product, is also not natural in a relational model. Usually this needs separate review tables and joins, which adds complexity. Overall, the relational model becomes less flexible when the structure of data changes often

## Section B: NoSQL Benefits (MongoDB)
MongoDB is a document database that stores data in JSON‑like documents instead of fixed tables. This gives a flexible schema, where each product document can have its own set of fields. A laptop document can include specs like RAM and processor, while a shoe document can have size and color, without forcing all products to share the same columns. This makes it easier to support many product types with different attributes. MongoDB also supports embedded documents, so customer reviews can be stored inside the same product document as an array. This keeps related information together and reduces the need for complex joins. When the product catalog grows, MongoDB supports horizontal scalability by sharding data across multiple servers. This helps handle large volumes of reads and writes. Overall, MongoDB fits use cases where schema changes frequently and nested, semi‑structured data is common.

## Section C: Trade-offs
Using MongoDB instead of MySQL also has some disadvantages. First, strong relational constraints like foreign keys and complex joins are not built in the same way, so enforcing relationships between collections often depends on application logic. This can increase the chance of inconsistent data if the application is not carefully written. Second, some types of analytical queries, especially those that need heavy joins or strict ACID transactions across many entities, may be easier and more efficient in a relational database. Teams that already know SQL and relational modeling may also need extra time to learn MongoDB tools and query language.

## testing for commits 
